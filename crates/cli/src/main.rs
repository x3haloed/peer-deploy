use std::time::Duration;

use anyhow::{Context, anyhow};
use clap::{Parser, Subcommand};
use futures::StreamExt;
use libp2p::{
    gossipsub, mdns,
    swarm::{Swarm, SwarmEvent},
    Multiaddr, PeerId, SwarmBuilder,
};
use tracing_subscriber::EnvFilter;
use base64::Engine;
use realm::tui;

use common::{serialize_message, Command, REALM_CMD_TOPIC, REALM_STATUS_TOPIC, OwnerKeypair, SignedManifest, AgentUpgrade, sign_bytes_ed25519};
use common::{InviteToken, InviteUnsigned, verify_bytes_ed25519};
use common::sha256_hex;

#[derive(Debug, Parser)]
#[command(name = "realm")]
#[command(about = "peer-deploy CLI", version, author)]
struct Cli {
    #[command(subcommand)]
    command: Commands,
}

#[derive(Debug, Subcommand)]
enum Commands {
    /// Generate local owner key
    Init,
    /// Display owner public key
    KeyShow,
    /// Send a hello to the network or run a wasm
    Apply {
        /// Optional wasm path to instruct agents to run (ad-hoc)
        #[arg(long)]
        wasm: Option<String>,
        /// Optional path to realm.toml to sign + publish
        #[arg(long)]
        file: Option<String>,
        /// Monotonic version for this manifest
        #[arg(long, default_value_t = 1)]
        version: u64,
    },
    /// Query status from agents and print first reply
    Status,
    /// Install the agent as a service (systemd user service by default)
    Install {
        /// Path to the agent binary to install
        #[arg(long)]
        binary: String,
        /// Install as a system service (requires root on most systems)
        #[arg(long, default_value_t = false)]
        system: bool,
    },
    /// Push an agent binary upgrade to all peers
    Upgrade {
        /// Path to agent binary to distribute
        #[arg(long)]
        file: String,
        /// Monotonic version for the agent binary
        #[arg(long, default_value_t = 1)]
        version: u64,
    },
    /// Create a signed invite token for bootstrapping a new peer
    Invite {
        /// Bootstrap multiaddr(s) to seed initial connectivity (repeat flag)
        #[arg(long)]
        bootstrap: Vec<String>,
        /// Optional realm identifier
        #[arg(long)]
        realm_id: Option<String>,
        /// Expiration in minutes from now (0 = no expiry)
        #[arg(long, default_value_t = 60)]
        exp_mins: u64,
    },
    /// Enroll a new peer using an invite token; optionally install the agent
    Enroll {
        /// Base64 invite token generated by `realm invite`
        #[arg(long)]
        token: String,
        /// Optional path to agent binary; if provided, will install
        #[arg(long)]
        binary: Option<String>,
        /// Install as a system service (Unix only)
        #[arg(long, default_value_t = false)]
        system: bool,
    },
    /// Manually configure trust and bootstrap peers
    Configure {
        /// Owner public key (bs58, e.g., ed25519:...)
        #[arg(long)]
        owner: String,
        /// Bootstrap multiaddr(s) to seed initial connectivity (repeat flag)
        #[arg(long)]
        bootstrap: Vec<String>,
    },
}

#[derive(libp2p::swarm::NetworkBehaviour)]
struct NodeBehaviour {
    gossipsub: gossipsub::Behaviour,
    mdns: mdns::tokio::Behaviour,
}

#[tokio::main(flavor = "multi_thread")]
async fn main() -> anyhow::Result<()> {
    tracing_subscriber::fmt()
        .with_env_filter(EnvFilter::from_default_env())
        .with_target(false)
        .compact()
        .init();

    // If no args, launch TUI as default operating mode
    if std::env::args().len() == 1 {
        return tui::run_tui().await;
    }

    let cli = Cli::parse();

    match cli.command {
        Commands::Init => init().await,
        Commands::KeyShow => key_show().await,
        Commands::Apply { wasm, file, version } => apply(wasm, file, version).await,
        Commands::Status => status().await,
        #[cfg(unix)]
        Commands::Install { binary, system } => install(binary, system).await,
        #[cfg(not(unix))]
        Commands::Install { .. } => Err(anyhow!("install is only supported on Unix-like systems with systemd")),
        Commands::Upgrade { file, version } => upgrade(file, version).await,
        Commands::Invite { bootstrap, realm_id, exp_mins } => invite(bootstrap, realm_id, exp_mins).await,
        Commands::Enroll { token, binary, system } => enroll(token, binary, system).await,
        Commands::Configure { owner, bootstrap } => configure(owner, bootstrap).await,
    }
}

fn owner_dir() -> anyhow::Result<std::path::PathBuf> {
    Ok(dirs::config_dir().context("config dir")?.join("realm"))
}

async fn init() -> anyhow::Result<()> {
    let dir = owner_dir()?;
    tokio::fs::create_dir_all(&dir).await?;

    let key_path = dir.join("owner.key.json");
    if tokio::fs::try_exists(&key_path).await? {
        println!("owner key already exists at {}", key_path.display());
        return Ok(());
    }

    let kp = OwnerKeypair::generate()?;
    let json = serde_json::to_vec_pretty(&kp)?;
    tokio::fs::write(&key_path, json).await?;
    println!("initialized; owner pub: {}", kp.public_bs58);

    // Generate a sample realm.toml pointing to hello.wasm if present
    let hello_path = std::path::Path::new("target/wasm32-wasip1/debug/hello.wasm");
    if hello_path.exists() {
        let bytes = tokio::fs::read(hello_path).await.unwrap_or_default();
        let digest = sha256_hex(&bytes);
        let sample = format!(
            "[components.hello]\nsource = \"file:{}\"\nsha256_hex = \"{}\"\nmemory_max_mb = 64\nfuel = 5000000\nepoch_ms = 100\n",
            hello_path.display(), digest
        );
        let sample_path = dir.join("realm.sample.toml");
        tokio::fs::write(&sample_path, sample).await.ok();
        println!("wrote sample manifest at {}", sample_path.display());
    }
    Ok(())
}

async fn key_show() -> anyhow::Result<()> {
    let key_path = owner_dir()?.join("owner.key.json");
    let bytes = tokio::fs::read(&key_path).await.context("read owner key")?;
    let kp: OwnerKeypair = serde_json::from_slice(&bytes)?;
    println!("{}", kp.public_bs58);
    Ok(())
}

fn agent_data_dir_cli() -> anyhow::Result<std::path::PathBuf> {
    Ok(dirs::data_dir().context("data dir")?.join("realm-agent"))
}

async fn write_trusted_owner(pub_bs58: &str) -> anyhow::Result<()> {
    tokio::fs::create_dir_all(&agent_data_dir_cli()?).await?;
    let path = agent_data_dir_cli()?.join("owner.pub");
    tokio::fs::write(path, pub_bs58.as_bytes()).await?;
    Ok(())
}

async fn write_bootstrap(addrs: &[String]) -> anyhow::Result<()> {
    tokio::fs::create_dir_all(&agent_data_dir_cli()?).await?;
    let path = agent_data_dir_cli()?.join("bootstrap.json");
    let bytes = serde_json::to_vec_pretty(&addrs)?;
    tokio::fs::write(path, bytes).await?;
    Ok(())
}

async fn new_swarm() -> anyhow::Result<(Swarm<NodeBehaviour>, gossipsub::IdentTopic, gossipsub::IdentTopic)> {
    let id_keys = libp2p::identity::Keypair::generate_ed25519();

    let gossip_config = gossipsub::ConfigBuilder::default().build()?;
    let mut gossipsub = gossipsub::Behaviour::new(
        gossipsub::MessageAuthenticity::Signed(id_keys.clone()),
        gossip_config,
    ).map_err(|e| anyhow!(e))?;

    let topic_cmd = gossipsub::IdentTopic::new(REALM_CMD_TOPIC);
    let topic_status = gossipsub::IdentTopic::new(REALM_STATUS_TOPIC);
    gossipsub.subscribe(&topic_cmd)?;
    gossipsub.subscribe(&topic_status)?;

    let mdns_beh = mdns::tokio::Behaviour::new(mdns::Config::default(), PeerId::from(id_keys.public()))?;

    let behaviour = NodeBehaviour { gossipsub, mdns: mdns_beh };

    let swarm = SwarmBuilder::with_existing_identity(id_keys)
        .with_tokio()
        .with_quic()
        .with_dns()?
        .with_behaviour(|_| Ok(behaviour))?
        .build();

    Ok((swarm, topic_cmd, topic_status))
}

async fn apply(wasm: Option<String>, file: Option<String>, version: u64) -> anyhow::Result<()> {
    let (mut swarm, topic_cmd, _topic_status) = new_swarm().await?;
    libp2p::Swarm::listen_on(&mut swarm, "/ip4/0.0.0.0/udp/0/quic-v1".parse::<Multiaddr>().unwrap())?;

    // Brief mDNS warmup
    let start = std::time::Instant::now();
    while start.elapsed() < Duration::from_millis(600) {
        if let Some(event) = swarm.next().await {
            if let SwarmEvent::Behaviour(NodeBehaviourEvent::Mdns(ev)) = event {
                match ev {
                    mdns::Event::Discovered(list) => {
                        for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer); }
                    }
                    mdns::Event::Expired(list) => {
                        for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer); }
                    }
                }
            }
        }
    }

    // ad-hoc hello/run path still supported
    let hello = Command::Hello { from: hostname::get().unwrap_or_default().to_string_lossy().into_owned() };
    swarm.behaviour_mut().gossipsub.publish(topic_cmd.clone(), serialize_message(&hello))?;

    if let Some(path) = wasm {
        let run = Command::Run { wasm_path: path, memory_max_mb: 64, fuel: 5_000_000, epoch_ms: 100 };
        swarm.behaviour_mut().gossipsub.publish(topic_cmd.clone(), serialize_message(&run))?;
    }

    if let Some(manifest_path) = file {
        let toml_bytes = tokio::fs::read(&manifest_path).await?;
        let toml_str = String::from_utf8(toml_bytes.clone()).context("realm.toml utf8")?;
        // load owner key
        let dir = owner_dir()?;
        let key_path = dir.join("owner.key.json");
        let bytes = tokio::fs::read(&key_path).await.context("read owner key")?;
        let kp: OwnerKeypair = serde_json::from_slice(&bytes)?;
        let sig = sign_bytes_ed25519(&kp.private_hex, toml_bytes.as_slice())?;
        let signed = SignedManifest {
            alg: "ed25519".into(),
            owner_pub_bs58: kp.public_bs58.clone(),
            version,
            manifest_toml: toml_str,
            signature_b64: base64::engine::general_purpose::STANDARD.encode(sig),
        };
        swarm.behaviour_mut().gossipsub.publish(topic_cmd.clone(), serialize_message(&Command::ApplyManifest(signed)))?;
    }

    tokio::time::sleep(Duration::from_millis(500)).await;
    Ok(())
}

async fn status() -> anyhow::Result<()> {
    let (mut swarm, topic_cmd, topic_status) = new_swarm().await?;
    libp2p::Swarm::listen_on(&mut swarm, "/ip4/0.0.0.0/udp/0/quic-v1".parse::<Multiaddr>().unwrap())?;

    swarm
        .behaviour_mut()
        .gossipsub
        .publish(topic_cmd.clone(), serialize_message(&Command::StatusQuery))?;

    let timeout = tokio::time::timeout(Duration::from_secs(5), async {
        loop {
            match swarm.select_next_some().await {
                SwarmEvent::Behaviour(NodeBehaviourEvent::Mdns(ev)) => {
                    match ev {
                        mdns::Event::Discovered(list) => {
                            for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer); }
                        }
                        mdns::Event::Expired(list) => {
                            for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer); }
                        }
                    }
                }
                SwarmEvent::Behaviour(NodeBehaviourEvent::Gossipsub(ev)) => {
                    if let gossipsub::Event::Message { message, .. } = ev {
                        if message.topic == topic_status.hash() {
                            println!("{}", String::from_utf8_lossy(&message.data));
                            break;
                        }
                    }
                }
                _ => {}
            }
        }
    });

    match timeout.await {
        Ok(_) => Ok(()),
        Err(_) => {
            println!("no status received");
            Ok(())
        }
    }
}

#[cfg(unix)]
async fn install(binary: String, system: bool) -> anyhow::Result<()> {
    use std::os::unix::fs::{PermissionsExt, symlink};
    if system {
        // System-wide install
        let data_bin_dir = std::path::Path::new("/usr/local/lib/realm-agent/bin");
        if tokio::fs::create_dir_all(&data_bin_dir).await.is_err() {
            println!("failed to create {}. try: sudo mkdir -p {}", data_bin_dir.display(), data_bin_dir.display());
            return Ok(());
        }
        let bin_bytes = tokio::fs::read(&binary).await?;
        let digest = sha256_hex(&bin_bytes);
        let versioned = data_bin_dir.join(format!("realm-agent-{}", &digest[..16]));
        tokio::fs::write(&versioned, &bin_bytes).await?;
        let _ = tokio::fs::set_permissions(&versioned, std::fs::Permissions::from_mode(0o755)).await;

        // Symlink current -> versioned
        let current_link = data_bin_dir.join("current");
        let _ = tokio::fs::remove_file(&current_link).await;
        let _ = symlink(&versioned, &current_link);

        // Convenience symlink in /usr/local/bin
        let usr_bin_link = std::path::Path::new("/usr/local/bin").join("realm-agent");
        let _ = tokio::fs::remove_file(&usr_bin_link).await;
        let _ = symlink(&current_link, &usr_bin_link);

        let unit_path = std::path::Path::new("/etc/systemd/system").join("realm-agent.service");
        let unit = format!("[Unit]\nDescription=Realm Agent\nAfter=network-online.target\nWants=network-online.target\n\n[Service]\nExecStart={}\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n", current_link.display());
        if tokio::fs::write(&unit_path, unit).await.is_err() {
            println!("failed to write {}. try: sudo tee {} < <(echo unit) && sudo systemctl daemon-reload", unit_path.display(), unit_path.display());
            return Ok(());
        }
        let _ = std::process::Command::new("systemctl").args(["daemon-reload"]).status();
        let _ = std::process::Command::new("systemctl").args(["enable", "--now", "realm-agent"]).status();
        println!("installed and started system service realm-agent");
        return Ok(());
    }

    // User-mode install (dev)
    let bin_dir = dirs::home_dir().context("home dir")?.join(".local/bin");
    tokio::fs::create_dir_all(&bin_dir).await?;
    let data_bin_dir = dirs::data_dir().context("data dir")?.join("realm-agent").join("bin");
    tokio::fs::create_dir_all(&data_bin_dir).await?;
    let bin_bytes = tokio::fs::read(&binary).await?;
    let digest = sha256_hex(&bin_bytes);
    let versioned = data_bin_dir.join(format!("realm-agent-{}", &digest[..16]));
    tokio::fs::write(&versioned, &bin_bytes).await?;
    let _ = tokio::fs::set_permissions(&versioned, std::fs::Permissions::from_mode(0o755)).await;

    // current -> versioned in data dir
    let current_link = data_bin_dir.join("current");
    let _ = tokio::fs::remove_file(&current_link).await;
    let _ = symlink(&versioned, &current_link);

    // ~/.local/bin/realm-agent -> current
    let target_link = bin_dir.join("realm-agent");
    let _ = tokio::fs::remove_file(&target_link).await;
    let _ = symlink(&current_link, &target_link);

    let systemd_dir = dirs::config_dir().context("config dir")?.join("systemd/user");
    tokio::fs::create_dir_all(&systemd_dir).await?;
    let service_path = systemd_dir.join("realm-agent.service");
    let service = format!("[Unit]\nDescription=Realm Agent\n\n[Service]\nExecStart={}\nRestart=always\n\n[Install]\nWantedBy=default.target\n", current_link.display());
    tokio::fs::write(&service_path, service).await?;

    if std::process::Command::new("systemctl").args(["--user", "daemon-reload"]).status().is_ok() {
        let _ = std::process::Command::new("systemctl").args(["--user", "enable", "--now", "realm-agent"]).status();
        println!("installed and started systemd user service realm-agent");
        println!("note: user services do not start at boot without a user session. to enable lingering: 'loginctl enable-linger $(whoami)'");
    } else {
        println!("service file written to {}. enable with: systemctl --user enable --now realm-agent", service_path.display());
        println!("note: user services do not start at boot without a user session. to enable lingering: 'loginctl enable-linger $(whoami)'");
    }
    Ok(())
}

async fn upgrade(file: String, version: u64) -> anyhow::Result<()> {
    let (mut swarm, topic_cmd, _topic_status) = new_swarm().await?;
    libp2p::Swarm::listen_on(&mut swarm, "/ip4/0.0.0.0/udp/0/quic-v1".parse::<Multiaddr>().unwrap())?;

    // mDNS warmup like apply
    let start = std::time::Instant::now();
    while start.elapsed() < Duration::from_millis(600) {
        if let Some(event) = swarm.next().await {
            if let SwarmEvent::Behaviour(NodeBehaviourEvent::Mdns(ev)) = event {
                match ev {
                    mdns::Event::Discovered(list) => {
                        for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.add_explicit_peer(&peer); }
                    }
                    mdns::Event::Expired(list) => {
                        for (peer, _addr) in list { swarm.behaviour_mut().gossipsub.remove_explicit_peer(&peer); }
                    }
                }
            }
        }
    }

    // load owner key
    let dir = owner_dir()?;
    let key_path = dir.join("owner.key.json");
    let bytes = tokio::fs::read(&key_path).await.context("read owner key")?;
    let kp: OwnerKeypair = serde_json::from_slice(&bytes)?;

    let bin_bytes = tokio::fs::read(&file).await?;
    let digest = sha256_hex(&bin_bytes);
    let sig = sign_bytes_ed25519(&kp.private_hex, &bin_bytes)?;
    let pkg = AgentUpgrade {
        alg: "ed25519".into(),
        owner_pub_bs58: kp.public_bs58.clone(),
        version,
        binary_sha256_hex: digest,
        binary_b64: base64::engine::general_purpose::STANDARD.encode(&bin_bytes),
        signature_b64: base64::engine::general_purpose::STANDARD.encode(sig),
    };
    swarm
        .behaviour_mut()
        .gossipsub
        .publish(topic_cmd.clone(), serialize_message(&Command::UpgradeAgent(pkg)))?;

    tokio::time::sleep(Duration::from_millis(500)).await;
    Ok(())
}

async fn invite(bootstrap: Vec<String>, realm_id: Option<String>, exp_mins: u64) -> anyhow::Result<()> {
    // load owner key
    let dir = owner_dir()?;
    let key_path = dir.join("owner.key.json");
    let bytes = tokio::fs::read(&key_path).await.context("read owner key")?;
    let kp: OwnerKeypair = serde_json::from_slice(&bytes)?;

    let exp_unix = if exp_mins == 0 { None } else {
        let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH)?.as_secs();
        Some(now + exp_mins * 60)
    };
    let unsigned = InviteUnsigned {
        alg: "ed25519".into(),
        owner_pub_bs58: kp.public_bs58.clone(),
        bootstrap_multiaddrs: bootstrap,
        realm_id,
        exp_unix,
    };
    let unsigned_bytes = serde_json::to_vec(&unsigned)?;
    let sig = sign_bytes_ed25519(&kp.private_hex, &unsigned_bytes)?;
    let token = InviteToken { unsigned, signature_b64: base64::engine::general_purpose::STANDARD.encode(sig) };
    let token_json = serde_json::to_vec(&token)?;
    let token_b64 = base64::engine::general_purpose::STANDARD.encode(token_json);
    println!("{}", token_b64);
    Ok(())
}

async fn enroll(token_b64: String, binary: Option<String>, system: bool) -> anyhow::Result<()> {
    let token_bytes = base64::engine::general_purpose::STANDARD.decode(token_b64)?;
    let token: InviteToken = serde_json::from_slice(&token_bytes)?;

    // verify signature
    let unsigned_bytes = serde_json::to_vec(&token.unsigned)?;
    let sig = base64::engine::general_purpose::STANDARD.decode(&token.signature_b64)?;
    let ok = verify_bytes_ed25519(&token.unsigned.owner_pub_bs58, &unsigned_bytes, &sig)?;
    if !ok { return Err(anyhow!("invalid invite signature")); }

    if let Some(exp) = token.unsigned.exp_unix {
        let now = std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH)?.as_secs();
        if now > exp { return Err(anyhow!("invite token expired")); }
    }

    write_trusted_owner(&token.unsigned.owner_pub_bs58).await?;
    write_bootstrap(&token.unsigned.bootstrap_multiaddrs).await?;

    if let Some(bin) = binary {
        #[cfg(unix)]
        { return install(bin, system).await; }
        #[cfg(not(unix))]
        { println!("configured. please install the agent binary separately."); return Ok(()); }
    }

    println!("configured. run 'realm install --binary <path>' to install the agent.");
    Ok(())
}

async fn configure(owner: String, bootstrap: Vec<String>) -> anyhow::Result<()> {
    write_trusted_owner(&owner).await?;
    write_bootstrap(&bootstrap).await?;
    println!("configured trusted owner and bootstrap peers");
    Ok(())
}
