---
alwaysApply: true
---

# Interface Parity and UX Consistency

Maintain feature parity and a consistent UX across the three user surfaces:

- CLI flags and subcommands (see [crates/cli/src/main.rs](mdc:crates/cli/src/main.rs), [crates/cli/src/cmd](mdc:crates/cli/src/cmd))
- TUI flows and wizards (see [crates/cli/src/tui/mod.rs](mdc:crates/cli/src/tui/mod.rs), [crates/cli/src/tui/draw.rs](mdc:crates/cli/src/tui/draw.rs))
- TOML manifest schema (see [crates/common/src/lib.rs](mdc:crates/common/src/lib.rs) for `Manifest`, `ComponentSpec`)

Agent-side enforcement/behavior lives in:
- [crates/agent/src/p2p/handlers.rs](mdc:crates/agent/src/p2p/handlers.rs)
- [crates/agent/src/p2p/mod.rs](mdc:crates/agent/src/p2p/mod.rs)
- [crates/agent/src/runner.rs](mdc:crates/agent/src/runner.rs)
- [crates/agent/src/supervisor.rs](mdc:crates/agent/src/supervisor.rs)

## Golden Rule
When you add or change a platform capability that configures component behavior, you MUST reflect it in all applicable interfaces:

- Update `ComponentSpec` / `Manifest` types to carry the new option.
- Add/adjust CLI options to set the value (`realm push`, `realm apply`).
- Add/adjust TUI wizard steps to collect the value.
- Ensure agent reads and enforces the value (handlers/supervisor/runner).
- Document briefly in `README.md`.

Examples of platform options that MUST be kept in sync:
- Resource limits (e.g., memory, fuel, epoch)
- Execution topology (replicas, selection by peer IDs/tags)
- Artifacts and integrity (source, digest)
- New runtime features (e.g., mounts, environment, args, routes)

## Allowed Exceptions (Do NOT add to TOML)
Operational actions that are not part of desired state should not appear in the TOML schema. They should exist in CLI/TUI only.

- Installation flows (e.g., `realm install`, TUI `I`).
- One-off visualizations (e.g., a TUI chart of peer churn).
- Ad-hoc queries (e.g., `realm status`, interactive log tails).

If a concept is visualization-only in the TUI, consider a CLI analogue that emits data once and exits (e.g., a timestamped event dump) but do not add it to the TOML.

## Practical Checklist for Any New Capability
1. Schema: extend `ComponentSpec` (and `Manifest` if needed) in [common/src/lib.rs](mdc:crates/common/src/lib.rs).
2. CLI:
   - Add flags in the relevant subcommand (e.g., [cmd/push.rs](mdc:crates/cli/src/cmd/push.rs)).
   - Serialize into the carrier type (e.g., `PushUnsigned`).
3. TUI:
   - Add fields/steps to the wizard in [tui/mod.rs](mdc:crates/cli/src/tui/mod.rs).
   - Validate input and show overlay errors for required values.
4. Agent:
   - Accept and persist via handlers in [p2p/mod.rs](mdc:crates/agent/src/p2p/mod.rs) / [handlers.rs](mdc:crates/agent/src/p2p/handlers.rs).
   - Reconcile/apply in [supervisor.rs](mdc:crates/agent/src/supervisor.rs) and enforce at runtime in [runner.rs](mdc:crates/agent/src/runner.rs).
5. Docs: add a brief bullet and example in [README.md](mdc:README.md).

## Decision Guide: Should it be in TOML?
- Is it desired state for continuous reconciliation (what should be running, with which limits/resources)?
  - Yes → Add to TOML + CLI + TUI.
  - No → Keep to CLI/TUI ops only.

## Example: Mounts (preopened directories)
- TOML: add `mounts` to `ComponentSpec`.
- CLI: `realm push --mount host=/var/www,guest=/www,ro=true` (repeatable).
- TUI: wizard steps to add/edit mounts; validate host path required.
- Agent: preopen host dirs in WASI context in `runner.rs`.

## Validation & Tests
- Reject unknown/unsupported options early at the CLI/TUI layer with clear error messages.
- Agent must validate inputs (e.g., refuse mounts outside allowed dirs if policy applies).
- Prefer schema-derived structs over ad-hoc maps to keep parity type-safe.

